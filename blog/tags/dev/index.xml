<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>dev on Hello World</title><link>https://deadlysyn.com/blog/tags/dev/</link><description>Recent content in dev on Hello World</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 23 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://deadlysyn.com/blog/tags/dev/index.xml" rel="self" type="application/rss+xml"/><item><title>AWS SDK Role Assumption</title><link>https://deadlysyn.com/blog/posts/aws-sdk-role-assumption/</link><pubDate>Sun, 23 Jan 2022 00:00:00 +0000</pubDate><guid>https://deadlysyn.com/blog/posts/aws-sdk-role-assumption/</guid><description>Short and sweet reminder to future self&amp;hellip;
I previously mentioned we follow the AWS best practice of sandboxing teams or services in dedicated accounts. It&amp;rsquo;s such a common practice, most likely you do too. In turn, you use cross-account role assumption when accessing resources (ideally using aws-vault).
That&amp;rsquo;s all well and good for humans, but a common requirement is ensuring services leverage the same role assumption. The exact implementation will vary a bit depending on your language of choice, but thankfully the AWS SDK makes this easy.</description></item><item><title>Beware of Shadows</title><link>https://deadlysyn.com/blog/posts/beware-of-shadows/</link><pubDate>Tue, 11 Jan 2022 00:00:00 +0000</pubDate><guid>https://deadlysyn.com/blog/posts/beware-of-shadows/</guid><description>You&amp;rsquo;re a humble DevOps practitioner. You like Go because it&amp;rsquo;s beautifully C-like without requiring real smarts most modern DevOps tools are written in it. You&amp;rsquo;ve read Effective Go a few times, understand block scope and rely heavily on redeclaration.
One day you write this snippet (obfuscated to protect the guilty) which lints, compiles and passes all tests (clearly I could use better tests):
// in a caller far, far away... ctx := context.</description></item><item><title>Introducing Retriever</title><link>https://deadlysyn.com/blog/posts/retriever/</link><pubDate>Sat, 04 Dec 2021 00:00:00 +0000</pubDate><guid>https://deadlysyn.com/blog/posts/retriever/</guid><description>The AWS SDK is great. Writing boilerplate for simple tasks is&amp;hellip; Well, you have better things to do.
Whether creating CLIs or services, one task I routinely encounter is secrets management. With AWS, I might use Secrets Manager (advanced features such as versioning simplify programmatic rotation) or Parameter Store (cost savings at scale, works great for injecting container environment).
I find myself repeating boilerplate (load configuration, create client, retrieve secret):</description></item><item><title>Lock Down</title><link>https://deadlysyn.com/blog/posts/lock-down/</link><pubDate>Mon, 23 Mar 2020 00:00:00 +0000</pubDate><guid>https://deadlysyn.com/blog/posts/lock-down/</guid><description>The old days of throwing up a CGI app protected by an .htpasswd file are long gone. While you could still do it, more sophisticated apps serving increasingly demanding users will have requirements that make it untenable.
For example, what if you have a suite of apps and don&amp;rsquo;t want users to have to login again for each one? What if you don&amp;rsquo;t want to manage all those .htpasswd files, or users want to login with their existing social identities?</description></item><item><title>Observability in Node.js</title><link>https://deadlysyn.com/blog/posts/observability-in-node-js/</link><pubDate>Fri, 01 Nov 2019 00:00:00 +0000</pubDate><guid>https://deadlysyn.com/blog/posts/observability-in-node-js/</guid><description>Observability has always been directly linked to reliability in distributed systems. After all, it&amp;rsquo;s hard to reason about things you can not see. Thanks in part to Google&amp;rsquo;s espousal of Site Reliability Engineering principles (the SRE Bible has been a free read on-line for awhile now, so go check that out if you haven&amp;rsquo;t yet!), the continuous evolution of our craft, and an abundance of cloud native tooling&amp;hellip; observing value-producing things is easier than ever.</description></item><item><title>Making Promises in Node.js</title><link>https://deadlysyn.com/blog/posts/making-promises-in-nodejs/</link><pubDate>Tue, 29 Oct 2019 00:00:00 +0000</pubDate><guid>https://deadlysyn.com/blog/posts/making-promises-in-nodejs/</guid><description>I recently decided to refactor a small platform smoke test framework called Splinter I wrote a while back. Aside from applying lessons learned since instantiation and pulling in the latest Node LTS release, I wanted to cleanup code resembling callback hell by using async/await. It&amp;rsquo;s practically 2020 I thought, promises aren&amp;rsquo;t exactly new, so this will be easy!
I soon discovered good intentions line the road to callback hell&amp;hellip; Splinter simply executes minimalistic CRUD tests against MongoDB, MySQL, PostgreSQL, RabbitMQ and Redis.</description></item><item><title>Node Health Checks</title><link>https://deadlysyn.com/blog/posts/node-health-checks/</link><pubDate>Tue, 22 Oct 2019 00:00:00 +0000</pubDate><guid>https://deadlysyn.com/blog/posts/node-health-checks/</guid><description>Cloud Foundry (CF) has a concept of health checks. These can take a few forms, but the preferred approach is HTTP (vs port- or process-based checks). Applications can expose a /healthcheck endpoint which the Cloud Controller polls. If an application becomes unhealthy (indicated by non-200 HTTP status code), restarts are attempted.
There is a health check timeout which I like to think of as the startup timeout. During initial startup of the application, the health check process will wait this long (polling every couple seconds) for the app to become healthy.</description></item><item><title>Simple Things Matter</title><link>https://deadlysyn.com/blog/posts/simple-things-matter/</link><pubDate>Mon, 21 Oct 2019 00:00:00 +0000</pubDate><guid>https://deadlysyn.com/blog/posts/simple-things-matter/</guid><description>Often in life we rush through things we&amp;rsquo;ve done so many times we feel they are simple. Some times they are simple, but in social contexts it is easy to forget how a little time taken to be intentional can help others (or ourselves) in the future.
One example of this I encounter almost daily is git commit messages. Often you will see one-liners such as &amp;ldquo;fixed typo&amp;rdquo; or &amp;ldquo;squashed bug&amp;rdquo; â€“ most likely meaningful enough to the person who just spent hours tracking down the typo or figuring out how to fix the bug.</description></item></channel></rss>