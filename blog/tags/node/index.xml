<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>node on Hello World</title><link>https://deadlysyn.com/blog/tags/node/</link><description>Recent content in node on Hello World</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 08 Mar 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://deadlysyn.com/blog/tags/node/index.xml" rel="self" type="application/rss+xml"/><item><title>Thinking Inside the Box</title><link>https://deadlysyn.com/blog/posts/thinking-inside-the-box/</link><pubDate>Sun, 08 Mar 2020 00:00:00 +0000</pubDate><guid>https://deadlysyn.com/blog/posts/thinking-inside-the-box/</guid><description>Clone the project repo to follow along&amp;hellip;
This is going to be another multi-part series&amp;hellip; I don&amp;rsquo;t want to get too far ahead of myself, but the end goal is shipping a Node.js app using Amazon Web Service&amp;rsquo;s Elastic Container Service (ECS). We have to crawl before we can walk (or run an app), so this first article will cover the basics of getting a simple Node app containerized (feel free to plug in whatever app you want).</description></item><item><title>Observability in Node.js</title><link>https://deadlysyn.com/blog/posts/observing-node-js-apps/</link><pubDate>Fri, 01 Nov 2019 00:00:00 +0000</pubDate><guid>https://deadlysyn.com/blog/posts/observing-node-js-apps/</guid><description>Observability has always been directly linked to reliability in distributed systems. After all, it&amp;rsquo;s hard to reason about things you can not see. Thanks in part to Google&amp;rsquo;s espousal of Site Reliability Engineering principles (the SRE Bible has been a free read on-line for awhile now, so go check that out if you haven&amp;rsquo;t yet!), the continuous evolution of our craft, and an abundance of cloud native tooling&amp;hellip; observing value-producing things is easier than ever.</description></item><item><title>Making Promises in Node.js</title><link>https://deadlysyn.com/blog/posts/making-promises-in-nodejs/</link><pubDate>Tue, 29 Oct 2019 00:00:00 +0000</pubDate><guid>https://deadlysyn.com/blog/posts/making-promises-in-nodejs/</guid><description>I recently decided to refactor a small platform smoke test framework called Splinter I wrote a while back. Aside from applying lessons learned since instantiation and pulling in the latest Node LTS release, I wanted to cleanup code resembling callback hell by using async/await. It&amp;rsquo;s practically 2020 I thought, promises aren&amp;rsquo;t exactly new, so this will be easy!
I soon discovered good intentions line the road to callback hell&amp;hellip; Splinter simply executes minimalistic CRUD tests against MongoDB, MySQL, PostgreSQL, RabbitMQ and Redis.</description></item><item><title>Node Health Checks</title><link>https://deadlysyn.com/blog/posts/node-health-checks/</link><pubDate>Tue, 22 Oct 2019 00:00:00 +0000</pubDate><guid>https://deadlysyn.com/blog/posts/node-health-checks/</guid><description>Cloud Foundry (CF) has a concept of health checks. These can take a few forms, but the preferred approach is HTTP (vs port- or process-based checks). Applications can expose a /healthcheck endpoint which the Cloud Controller polls. If an application becomes unhealthy (indicated by non-200 HTTP status code), restarts are attempted.
There is a health check timeout which I like to think of as the startup timeout. During initial startup of the application, the health check process will wait this long (polling every couple seconds) for the app to become healthy.</description></item></channel></rss>