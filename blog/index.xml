<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hello World</title><link>https://deadlysyn.com/blog/</link><description>Recent content on Hello World</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 10 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://deadlysyn.com/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Safely Expose Credentials</title><link>https://deadlysyn.com/blog/posts/safely-expose-credentials/</link><pubDate>Thu, 10 Mar 2022 00:00:00 +0000</pubDate><guid>https://deadlysyn.com/blog/posts/safely-expose-credentials/</guid><description>If you&amp;rsquo;re juggling STS credentials while wrangling more AWS accounts than you can count, you&amp;rsquo;ve likely heard of aws-vault. Aside from the convenience factor, it&amp;rsquo;s also good for security (keep plain-text credentials off disk).
Similarly, it&amp;rsquo;s obvious you don&amp;rsquo;t want to commit credentials. Depending how far you take that, even committing encrypted credentials (or storing them anywhere not intended for managing secrets) should be discouraged.
One reason is building up muscle memory and inviting accidental commits of unencrypted secrets (use something like gitleaks to prevent that).</description></item><item><title>AWS SDK Role Assumption</title><link>https://deadlysyn.com/blog/posts/aws-sdk-role-assumption/</link><pubDate>Sun, 23 Jan 2022 00:00:00 +0000</pubDate><guid>https://deadlysyn.com/blog/posts/aws-sdk-role-assumption/</guid><description>Short and sweet reminder to future self&amp;hellip;
I previously mentioned we follow the AWS best practice of sandboxing teams or services in dedicated accounts. It&amp;rsquo;s such a common practice, most likely you do too. In turn, you use cross-account role assumption when accessing resources (ideally using aws-vault).
That&amp;rsquo;s all well and good for humans, but a common requirement is ensuring services leverage the same role assumption. The exact implementation will vary a bit depending on your language of choice, but thankfully the AWS SDK makes this easy.</description></item><item><title>Lean IAM Management</title><link>https://deadlysyn.com/blog/posts/lean-aws-iam/</link><pubDate>Sun, 16 Jan 2022 00:00:00 +0000</pubDate><guid>https://deadlysyn.com/blog/posts/lean-aws-iam/</guid><description>Part of DevOps culture is avoiding tickets when automation can provide lower-friction alternatives. Similarly, the SRE mindset seeks to eliminate toil. We also know from experience that the most effective Agile teams are granted a high level of autonomy.
IAM is a routine stumbling block to autonomy. Teams need an &amp;ldquo;appropriate&amp;rdquo; level of access to do their job. That often turns into waiting on tickets, with another team twiddling bits to unblock development.</description></item><item><title>Beware of Shadows</title><link>https://deadlysyn.com/blog/posts/beware-of-shadows/</link><pubDate>Tue, 11 Jan 2022 00:00:00 +0000</pubDate><guid>https://deadlysyn.com/blog/posts/beware-of-shadows/</guid><description>You&amp;rsquo;re a humble DevOps practitioner. You like Go because it&amp;rsquo;s beautifully C-like without requiring real smarts most modern DevOps tools are written in it. You&amp;rsquo;ve read Effective Go a few times, understand block scope and rely heavily on redeclaration.
One day you write this snippet (obfuscated to protect the guilty) which lints, compiles and passes all tests (clearly I could use better tests):
// in a caller far, far away... ctx := context.</description></item><item><title>AWS WAF Module</title><link>https://deadlysyn.com/blog/posts/aws-waf-module/</link><pubDate>Fri, 10 Dec 2021 00:00:00 +0000</pubDate><guid>https://deadlysyn.com/blog/posts/aws-waf-module/</guid><description>NOTE: This includes AWSManagedRulesKnownBadInputsRuleSet by default, which AWS updated to mitigate the recent Log4j issue (CVE-2021-44228).
Just released a Terraform module for AWS WAF. If you host &amp;ldquo;standard&amp;rdquo; web services (atop something Linux-like), this takes an opinionated approach to save you time while providing enough flexibility for common use cases.
module &amp;#34;waf&amp;#34; { source = &amp;#34;git::ssh://git@github.com/sonatype/terraform-aws-waf.git?ref=v0.0.1&amp;#34; association_arns = [module.foo.alb_arn] environment = var.environment name = var.name namespace = var.namespace tags = var.</description></item><item><title>Introducing Retriever</title><link>https://deadlysyn.com/blog/posts/retriever/</link><pubDate>Sat, 04 Dec 2021 00:00:00 +0000</pubDate><guid>https://deadlysyn.com/blog/posts/retriever/</guid><description>The AWS SDK is great. Writing boilerplate for simple tasks is&amp;hellip; Well, you have better things to do.
Whether creating CLIs or services, one task I routinely encounter is secrets management. With AWS, I might use Secrets Manager (advanced features such as versioning simplify programmatic rotation) or Parameter Store (cost savings at scale, works great for injecting container environment).
I find myself repeating boilerplate (load configuration, create client, retrieve secret):</description></item><item><title>Go Datadog CLI</title><link>https://deadlysyn.com/blog/posts/go-datadog-cli/</link><pubDate>Mon, 29 Nov 2021 00:00:00 +0000</pubDate><guid>https://deadlysyn.com/blog/posts/go-datadog-cli/</guid><description>I found myself wrapping ChatOps around a CI/CD pipeline to manage scheduled downtime in DataDog (avoiding SLO impact for planned work). For astute readers wondering why this wasn&amp;rsquo;t a direct API call; I tend to (ab)use CI as a generic task runner (has an API, secret store, etc).
I wanted to identify resources using labels (team:foo, service:bar). While this is a common use case and things have hopefully improved, CLIs available at the time provided numerous ways to manage downtime but lacked tag support.</description></item><item><title>Keycloak IaC</title><link>https://deadlysyn.com/blog/posts/keycloak_iac/</link><pubDate>Sun, 28 Nov 2021 00:00:00 +0000</pubDate><guid>https://deadlysyn.com/blog/posts/keycloak_iac/</guid><description>Keycloak is a flexible, open source, identify access and management solution (Red Hat SSO being the commercial variant). While there is a growing community, much information is focused on service integration.
After Terraforming supporting infrastructure, I wanted to share a &amp;ldquo;batteries included&amp;rdquo; project to quickly get anyone adopting Keycloak up and running. If you already use Keycloak, it may provide inspiration. If you find it lacking, please help extend it for the greater good.</description></item></channel></rss>